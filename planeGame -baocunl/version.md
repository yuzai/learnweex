## 版本更迭

###　version 1.0.0 2016-12-13
可以实现打飞机。解决了move检测的问题。

### version 1.1.0 2016-12-14
#### 发现的issues:
1. 消失的子弹和敌机数组不能清空，因为清空会导致repear重新刷新，进而对子弹以及敌机的初始位置又会清空，回到初始位置，不能清空，会导致没有必要的内存消耗，同时随着时间的增加，会使得内存消耗越来越严重
#### 解决的问题及方法：
1. 子弹敌机数组删除的问题，**解决方案**：了解清楚了repeat的刷新方式，默认根据repeat追踪的数组的下标进行刷新，每次的删除节点，采用的是splice方式，会改变其后面的所有子弹的下标，所以导致了后面的数据的刷新，理论上只要制止刷新就可以解决这个问题，我采用的是给每一个子弹和敌机赋值一个独一无二的id(*此处引入一个bug:id会用光，之后解决*),repeat采用track-by这个id，即可实现删除和增加节点只进行局部刷新，而不是全部刷新，从而保全了之前的位置信息。

### version 2.0.0 2016-12-17
#### 发现的issues及原因分析
1. 在手机上运行很卡顿，时间越久越卡顿。因为每一个子弹以及敌机都设置了setInterval,每一个都具有一个定时函数，太多的定时函数会导致程序崩溃。
#### 解决的问题及方法
1. 事实上，每一个子弹以及敌机执行的方法都是一样的，下落一段距离（敌机）或者上升一段距离（子弹），检测碰撞均在另一个定时函数中全部运行。所以其实可以把所有子弹以及敌机的定时函数分别放到两个定时函数中，**在两个定时函数中对子弹数组以及敌机数组的每一个元素的高度进行加减操作即可实现原本的功能，同时大大减少了系统所需要的定时函数的数量。** 事实证明，速度明显提升，再也没有卡顿了。

### version 3.0.0 2016-12-18
#### 发现的issue及原因分析
1. 偶尔会出现子弹"打不中"敌机的现象，其实也不是打不中，本质是系统丢失了还没有被击中的敌机。在chrome dev-tools中调试的时候，发现，程序检测到了两者的碰撞，但是当触发销毁敌机的时候，出现了数组中不存在该敌机的错误。**原因定位**:问题出在两个定时函数的冲突上，严格来讲，程序是串行执行的，所以，当在执行检测函数的过程中，有可能会出现敌机产生的定时函数也执行，此时的数据的更改应该是交给了很顶层的Js部分来解决冲突，因为两者同时修改了一个数组，此时必然发生冲突，按照我的猜测，应该是一个栈机制，后来居上，但是会把之前未执行结束的数据全部保存在栈中，当后来者结束之后释放原来的数据，继续执行之前的函数。此时，后者的定时函数给数组新增了一个敌机，但是前者的length并未改变，所以会出现两者碰撞，检测不到敌机的情况。*只能猜测到大概原因，具体问题太底层了，暂时没有探究出来*
**12-19补充：** 找到了最终的问题：敌机的定时函数定时产生一辆敌机，将会出发repeat进行重新渲染，此时，dom里面才会有新的一个敌机，但是如果检测函数的定时函数早于重新渲染的时间，就会出现敌机节点不存在的问题。所以在产生敌机之后等待一段时间再执行检测函数就能很好的解决问题。目前来看，repeat应该是采用事件机制进行触发，大概的周期应该在20-30ms左右。
#### 解决方案
1. 在执行检测函数的时候暂停别的定时函数，我发现，没有现成的暂停setinterval的方法,所以采用在检测函数中进行敌机以及子弹的产生，通过计数的方式实现想要的定时时间。成功解决该问题。
